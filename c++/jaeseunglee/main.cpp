#include <iostream>

int main() {
    std::cout << "Hello, World!" << std::endl;

    /*  1. DDD를 수행하여 얻는 이점은 무엇인가요? 3가지 이상 기술하세요
     *      - ㄱ. 코드의 가시성이 높아짐
     *      - ㄴ. 코드의 유지보수가 용이해짐
     *      - ㄷ. 협업에 용이함
     *
     *  2. Domain이란 결국 무엇인가요?
     *      - 주제. 예를들어 UI Domain은 유저 인터페이스에 관한 모든 사항을 관리한다.
     *
     *  3. GoogleTest를 사용하는 이유가 무엇인가요?
     *      - 추상화 단계에서 구상한 기능을 사전에 만들어 볼 수 있음. 세부사항을 뒤로 미루고
     *      DDD를 만들기 위해 큰 틀을 계획할 수 있음
     *
     *  4. Test를 작성함으로서 얻는 이점은 무엇인가요?
     *      - 부분적으로 컴파일하여 테스트 해 볼 수 있음.
     *      또한 현재 어느 단계까지 문제가 없는지 파악 할 수 있으며,
     *      코드 수정 및 추가로 인해 기존의 동작에 문제가 생기면 즉각적으로 파악 할 수 있음
     *
     *  5. 이미 팀 단위 과제를 진행하며 경험했겠지만, Backlog를 작성 할 때
     *     Todo 리스트만 관리되면 어떤 문제가 발생하나요? (수업 중 리뷰 시간에도 따로 설명했습니다)
     *     - 협업 과정에서, 특정 기능을 담당하는 부분이 어디인지 서로 다른 해석을 내림으로써 혼선이 발생해
     *     오히려 협업 효율이 떨어지는 문제가 발생할 수 있음
     *     목적성이 불분명해짐
     *
     *  6. 작업 마다 커밋을 하지 않고 한 번에 몰아서 통 커밋을 하는 경우 어떤 문제가 발생하나요?
     *      - 커밋마다의 작업을 파악하기 힘들며, 혹여 Git에 문제가 생겨 히스토리를 되돌아가야 할 때
     *      손실이 큼
     *
     *  7. Backlog를 관리하지 않는 경우 어떤 문제가 발생하나요?
     *      - 협업 상황에서 작업 진척도 파악, 이슈 관리, 업무 배분등에 문제가 생길 가능성이 큼
     *
     *  8. 함수 포인터 배열을 사용함으로서 얻는 이득은 무엇인가요?
     *      - 협업이 용이함. DDD를 통해 서로 다른 기능을 작성하더라도 문제가 발생할 가능성이 매우 낮음
     *      ※IOC를 통해 하나의 작업에 문제가 생기거나 수정을 가하더라도 변경의 파급력이 매우 낮아짐
     *
     *
     *  9. API controller, Domain Service, Repository가 분리됨으로서 얻게 되는 이점은 무엇인가요?
     *      - 모듈화를 통해 서로의 기능을 알지 못하더라도 상호작용함에 있어서 문제가 생기지 않기에 협업이 용이
     *
     *      ※ api controller = 사용자 입력 및 웹 통신등의 요청을 수행하는 기능
     *      ※ Domain service = Entity = 특정 입력에 반응하는 ACTION
     *      ※ Repository = 세부사항(데이터)이 어디에 배치될 것인가
     *
     *  10.slack 채널 이슈를 살피지 않는 경우 무슨 일이 발생하나요?
     *  - 현재 발생한 이슈에 대해 이미 해결법이 나와 있음에도 불구하고 다시 질문함으로써 클래스 전체의 시간이 낭비될 수 있다.
     *  서로 작업의 진행상황을 파악하기가 힘들기 때문에 업무 진척도 파악이 힘듬
     *
     *
     *
     *
     *
     * */




    return 0;
}
